# #排序算法

## ##Linklist框架、leetcode81、82、147、148、153、154

### ###leetcode81

1.利用数组被切成2部分升序空间的特性，找到2段空间的交错点

2.分别对2段空间实行2分查找

### ###leetcode82

因为是排好序的链表，所以相同的元素必然相邻
（1）遍历链表，用N表示当前元素，M指向N的下一个元素，如果M.next.val==M.val，便将M向后移动，直至M.val发生变化。可以通过判断N.next是否等于M来判断M是否移动
（2）如果M发生了移动，便表示N与M之间为重复数字，N.next=M,将中间的重复数字全部舍弃

（3）如果没有与M的值相等的元素，则不进行其他操作，N=N.next

### ###leetcode147

（1）插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。

（2）每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。

（3）重复直到所有输入数据插入完为止。

### ###leetcode148

排序的思想是通过递归的方式不断找到数组中元素应该在的位置，最核心的算法就是partition方法。快排的时间复杂度为 O ( n l o g n ) 

### ###leetcode153

题目说了数组有旋转，所以如果旋转的点选择的不是边界的点，那么最小的值的点肯定是在数组的**中间位置**，所以旋转后数组的第一个元素肯定**大于**最小值以及最小值后面的元素同时又**小于**它后面的直到最小值的那一部分元素，那么可以用二分法进行寻找，将目标target设为nums[0]。

- 如果nums[mid]的值**小于**target，那么说明nums[mid]是在最小值的**后面**，r往中间靠，往前面找。
- 如果nums[mid]的值**大于等于**target，那么说明nums[mid]是在最小值的**前面**，l往中间靠，往后面找。
- 不断的寻找，直到l**不满足小于等于**r跳出循环，此时的l指向最小的值所在的位置。

### ###leetcode154

- 二分查找，定义left，right，mid

- 如果右边位置的数值大于中间，那么右边是排好序的数组，所以右边的最小值为mid的值，把mid赋给right，看看左边还有没有更小的

- 其他：

  如果right位置的数值小于，也就是右边的数组包含未旋转的数组的前几个元素，left = mid + 1

  其他：right和mid位置的数值可能相等，把right - 1，去掉重复值